# -*- coding: utf-8 -*-
# Copyright 2021 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""Runs asr eval tool with power measurements

Our autotest libraries already have code written to measure the power
levels in a device. Rather than re-implement these in C++, this script
wraps the asr_perf_eval tool and performs power measurements. It then
reports the overall results of the invocation to the screen.
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import argparse
import config
import csv
import logging
import os
import os.path
import power
import subprocess
import tempfile
import time
import signal

ASR_BINARY = "/usr/bin/asr_perf_eval"
ASR_LOCAL_BINARY = "/usr/local/bin/asr_perf_eval"
BYTES_TO_MB = 1024 * 1024
SOC_WATCH = "/opt/socwatch/socwatch"


def parse_args():
  parser = argparse.ArgumentParser()
  parser.add_argument(
      "--config_file", type=str, help="asr_perf_eval config file")
  parser.add_argument(
      "--csv_output_path", type=str, help="asr_perf_eval csv output file")
  parser.add_argument(
      "--disable_services",
      action="store_true",
      help=("Disables unneeded services and backlights to stabilize "
            "power and CPU load. Requires running as root."))
  parser.add_argument(
      "--wait_for_cooldown",
      action="store_true",
      help=("If set, waits until the cools down to --cooldown_temp."))
  parser.add_argument(
      "--cooldown_temp",
      type=float,
      default=40.0,
      help="Max temperature to cooldown to if --wait_for_cooldown is set")
  parser.add_argument(
      "--dictation_config_name", type=str, help="provide dictation config name used while creating symlink using script update_lp_config_symlink.py")

  gen_config_group = parser.add_argument_group(
      title="Generate Config File",
      description="These options will generate config file for asr_perf_eval "
      "based on the command line flags and the list of audio files "
      "from 'audio_test_files'")
  gen_config_group.add_argument(
      "--audio_files_proto",
      type=str,
      help="path to a file containing the set of 'audio_test_files' "
      "messages to use in a generated config. Do not use in "
      "conjunction with config_file.")
  gen_config_group.add_argument(
      "--soda_driver_path",
      default="libsoda_chromeos_keyless.so",
      type=str,
      help="soda_driver_path value to use in generated config. "
      "Only used with 'audio_files_proto', is ignored if "
      "'config_file' is used.")
  gen_config_group.add_argument(
      "--soda_lp_dir",
      default="/usr/local/ml_benchmark/soda/lp_quantized_no_nnapi",
      type=str,
      help="soda_lp_dir value to use in generated config. "
      "Only used with 'audio_files_proto', is ignored if "
      "'config_file' is used.")
  gen_config_group.add_argument(
      "--simulate_realtime",
      action="store_true",
      help="simulate_realtime value to use in generated config. "
      "Only used with 'audio_files_proto', is ignored if "
      "'config_file' is used.")

  return parser.parse_args()


def process_csv_file(csv_filename):
  """Processes a csv file generated by asr_perf_eval and populates a dict.

  This method will cast numerical types to floats.

  Args:
    csv_filename: The file generated by asr_perf_eval

  Returns:
    A dictionary with the keys as the header of the csv to a list of values.
  """
  results = {}

  numeric_fields = [
      "audio_duration_s", "speech_duration_s", "processing_duration_s",
      "speech_rtf", "audio_rtf", "soda_startup_latency",
      "seconds_to_first_transcription", "error_count", "word_count",
      "transcription_accuracy", "rss_swap_bytes", "vm_size_bytes",
      "vm_peak_bytes"
  ]
  with open(csv_filename) as f:
    reader = csv.reader(f, delimiter=",")
    headers = reader.next()
    results = {header: [] for header in headers}

    for row in reader:
      # Skip any rows that didn't generate an RTF value.
      if row[headers.index("speech_rtf")] == "inf":
        continue

      for idx, value in enumerate(row):
        header = headers[idx]
        results[header].append(
            float(value) if header in numeric_fields else value)

  return results


def print_results(results, power_m, runtime_s):
  """Aggregates and prints the top level asr performance metrics.

  Args:
    results: The output of the process_csv_file method.
    power_m: Instance of power.PowerMeasurements
    runtime_s: Duration of the benchmark in seconds
  """
  num_samples = float(len(results["filename"]))
  if num_samples == 0:
    print("\n**** No valid results in output file.")
    return

  avg_speech_rtf = sum(results["speech_rtf"]) / num_samples
  avg_audio_rtf = sum(results["audio_rtf"]) / num_samples
  wer = sum(results["error_count"]) / sum(results["word_count"]) * 100
  max_startup_ms = int(max(results["soda_startup_latency"]) * 1000)
  initial_mem = int(results["rss_swap_bytes"][0] / BYTES_TO_MB)
  final_mem = int(results["rss_swap_bytes"][-1] / BYTES_TO_MB)
  peak_mem = int(max(results["rss_swap_bytes"]) / BYTES_TO_MB)

  print("\n**** Results:")
  print("Average Speech RTF: {avg_rtf:.4f}".format(avg_rtf=avg_speech_rtf))
  print("Average Audio RTF: {avg_rtf:.4f}".format(avg_rtf=avg_audio_rtf))
  print("Word Error Rate: {wer:.2f}%".format(wer=wer))
  print("Max Startup Latency: {startup}ms".format(startup=max_startup_ms))
  print("Energy Usage: {e:.2f}mWh".format(e=power_m.energy_used_mwh()))
  print("Energy Usage (RAPL): {e:.2f}mWh".format(e=power_m.rapl_energy_used_mwh()))
  print("Average Power: {p:.2f}W".format(p=power_m.avg_power_w()))
  print("Average Power (RAPL): {p:.2f}W".format(p=power_m.rapl_avg_power_w()))
  print("Initial RSS Memory Usage: {mem}MB".format(mem=initial_mem))
  print("Final RSS Memory Usage: {mem}MB".format(mem=final_mem))
  print("Peak RSS Memory Usage: {mem}MB".format(mem=peak_mem))
  print("Total Runtime: {runtime:.2f}s".format(runtime=runtime_s))


def run_asr(csv_filename, config_file):
  _binary = None

  if os.path.isfile(ASR_BINARY):
    _binary = ASR_BINARY
  elif os.path.isfile(ASR_LOCAL_BINARY):
    _binary = ASR_LOCAL_BINARY
  else:
    print("Couldn't find asr_perf_eval binary.")
    return -1

  if os.path.isfile(SOC_WATCH):
    args = parse_args() 
    dictation_config_name = args.dictation_config_name
    _soc_wat_cmd = "/opt/socwatch/socwatch -r sum -m -f sys -t 1800 -o socwatch_" + dictation_config_name
  else:
      print("Couldn't find socwatch binary")
      return -1
  #launch socwatch
  socwatch = subprocess.Popen(_soc_wat_cmd,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
  time.sleep(4)

  exit_code = subprocess.call([
      _binary, "--csv_output_path={csv_file}".format(csv_file=csv_filename),
      "--config_file={config_file}".format(config_file=config_file)
  ])
  #stop socwatch
  print("Stop socwatch using ctlr-C")
  socwatch.send_signal(signal.SIGINT)
  time.sleep(10)

  return exit_code


def main():
  # Disable debug and info logs from power_status
  logging.getLogger().setLevel(logging.WARNING)

  args = parse_args()

  if args.csv_output_path:
    dictation_config_name = args.dictation_config_name
    csv_filename = args.csv_output_path + "asr_" + dictation_config_name
  else:
    fh, csv_filename = tempfile.mkstemp(prefix="asr-", suffix=".csv")
    os.close(fh)

  if args.config_file:
    config_file = args.config_file
    if args.audio_files_proto:
      print("*** Cannot specify 'config_file' and 'audio_files_proto'.")
      return
  elif args.audio_files_proto:
    config_file = config.generate_config_file(args.audio_files_proto,
                                              args.soda_driver_path,
                                              args.soda_lp_dir,
                                              args.simulate_realtime)
  else:
    print("*** Need to specify 'config_file', or 'audio_files_proto'.")
    return

  if args.wait_for_cooldown:
    print("*** Waiting for device to reach {temp}C".format(
        temp=args.cooldown_temp))
    if not power.wait_for_cooldown(args.cooldown_temp, 10):
      return

  with power.LoadMinimizer(enabled=args.disable_services):
    power_measurements = power.PowerMeasurements()
    power_measurements.start()

    time_start = time.time()

    exit_code = run_asr(csv_filename, config_file)

    power_measurements.stop()
    time_end = time.time()

  if exit_code != 0:
    return

  results = process_csv_file(csv_filename)

  if not power_measurements.has_battery():
    print("\n**** No battery found. 'Power Usage' will be zero.")
  if not power_measurements.has_rapl():
    print("\n**** No RAPL support. 'Power Usage (RAPL)' will be zero.")

  print_results(results, power_measurements, time_end - time_start)

  if args.audio_files_proto:
    os.remove(config_file)


if __name__ == "__main__":
  main()
